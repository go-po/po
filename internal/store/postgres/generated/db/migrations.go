package db

import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
	"strings"
)

func bindata_read(data []byte, name string) ([]byte, error) {
	gz, err := gzip.NewReader(bytes.NewBuffer(data))
	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	var buf bytes.Buffer
	_, err = io.Copy(&buf, gz)
	gz.Close()

	if err != nil {
		return nil, fmt.Errorf("Read %q: %v", name, err)
	}

	return buf.Bytes(), nil
}

var __1_create_records_down_sql = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\x01\x00\x00\xff\xff\x00\x00\x00\x00\x00\x00\x00\x00")

func _1_create_records_down_sql() ([]byte, error) {
	return bindata_read(
		__1_create_records_down_sql,
		"1_create_records.down.sql",
	)
}

var __1_create_records_up_sql = []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xa4\x94\x41\x6f\xe2\x30\x10\x85\xef\xf9\x15\x73\x2b\x48\x20\xed\xbd\x27\xda\xa6\x6d\x24\x36\x68\x69\xd8\x56\x7b\x89\x0c\x0c\xc1\x52\x62\x5b\xf6\x64\xb7\xdd\x5f\xbf\x8a\x13\x3b\x0d\x4b\x4a\x80\xdc\x22\xdb\xdf\x3c\x7b\xde\xbc\xe9\x14\xb8\xe0\xc4\x59\x0e\x66\xb3\xc7\x82\xc1\x4e\x6a\xa0\x3d\x42\x81\xc6\xb0\x0c\x4d\x70\xbf\x0c\x67\x49\x08\xc9\xec\x6e\x1e\x42\xf4\x08\xf1\x22\x81\xf0\x2d\x7a\x49\x5e\x40\xc9\xb4\x30\x99\x09\x46\x41\x00\x00\xb0\xd1\xc8\x08\xb7\x60\x3f\xe2\x05\x1a\x62\x85\x82\xd7\x28\x79\x86\x24\xfa\x1e\xc2\xaf\x45\x1c\xc2\x43\xf8\x38\x5b\xcd\x13\x88\x17\xaf\xa3\xb1\xa5\xc5\xab\xf9\x7c\x62\x09\xa5\xda\x5e\x49\x30\xa4\x91\x15\x35\x00\x7e\xce\x96\xf7\xcf\xb3\x25\x9c\xf8\xba\x04\x21\x3f\x2d\xdd\x45\x4f\x51\x9c\x1c\x39\xe3\x34\x7c\x3b\x42\xc8\xb4\x6a\x37\xfe\x66\x7a\xb3\x67\x7a\xb0\x06\x98\x4e\x21\xd3\xb2\x54\xc0\x05\x3c\x49\x07\x4c\xbd\xac\x5e\x49\x07\x40\x2f\x67\x23\x05\xa1\xa0\x94\x3e\x14\x9e\x2d\xc7\x12\xb6\x8c\x98\x5f\x5a\x7f\x10\xb2\x93\xe5\x3d\x21\x18\xdf\x06\xc1\x46\x16\x05\x0a\x02\x29\x80\xd8\x3a\x47\xe7\x1c\xe0\x06\x6e\x2a\x7d\x8c\x0b\xe3\x2d\x77\x73\x1b\x38\xd7\x45\xf1\x43\xf8\x76\xdc\x75\x69\xdd\xea\x94\x8b\x2d\xbe\xc3\x22\xf6\xcc\x51\xbd\x30\xbe\x1d\x02\xa9\x9e\xf6\x7f\x42\xa6\x55\x7b\x7c\x15\x47\x3f\x56\x83\xa4\x88\xb2\x58\xa3\x4e\xcb\x3e\x49\x13\x10\xf2\x2c\x6e\xa5\xce\x36\xbf\x17\x9c\x69\x35\x69\xfc\x31\x6e\x9f\xad\x7f\x58\xeb\xcb\x06\xa3\xce\xb8\xb5\x93\xf6\x87\xd3\xde\xfe\xc2\x5f\x29\x10\xb6\xb8\x63\x65\x4e\xcd\xa4\x09\x49\x20\xca\x3c\x9f\x74\xa6\xfd\xa2\xc3\x6e\x4c\x2f\x9b\x50\x7c\x27\xeb\x44\x9e\x71\x41\x47\xb6\xbb\xca\xf5\x70\xba\xca\x5f\x39\xb1\xf1\x40\xc7\x8e\x55\x0a\xda\x52\xf5\xeb\x03\x33\x86\x67\xa2\xba\xb1\x04\xd6\xdc\xe0\x93\x55\x4f\xb6\xb3\xae\xe1\xbc\x72\xd8\xcb\x46\x41\x6b\xde\x13\xbd\x54\xd2\x1c\x74\xd1\x7e\x03\xbb\xd1\x7d\xd0\x9e\xe0\x3e\x83\xd0\x89\xdd\x8b\x32\x26\xe7\x86\x50\xa0\xbe\x9c\xd0\x09\xee\x5e\x6f\x7c\x45\xb8\x26\xe7\xae\xcf\xda\x5e\x7f\x2a\x59\x07\xa5\x92\x86\x13\x97\x02\xe4\xce\x1b\xd0\xbf\xdb\x60\x27\x2a\xe9\xf3\xca\x9d\x6d\xcc\x68\x6f\x20\x85\x2b\xe9\x43\xcb\x6d\xab\xf4\xfd\x0b\x00\x00\xff\xff\x00\x92\xb4\x6f\x31\x08\x00\x00")

func _1_create_records_up_sql() ([]byte, error) {
	return bindata_read(
		__1_create_records_up_sql,
		"1_create_records.up.sql",
	)
}

// Asset loads and returns the asset for the given name.
// It returns an error if the asset could not be found or
// could not be loaded.
func Asset(name string) ([]byte, error) {
	cannonicalName := strings.Replace(name, "\\", "/", -1)
	if f, ok := _bindata[cannonicalName]; ok {
		return f()
	}
	return nil, fmt.Errorf("Asset %s not found", name)
}

// AssetNames returns the names of the assets.
func AssetNames() []string {
	names := make([]string, 0, len(_bindata))
	for name := range _bindata {
		names = append(names, name)
	}
	return names
}

// _bindata is a table, holding each asset generator, mapped to its name.
var _bindata = map[string]func() ([]byte, error){
	"1_create_records.down.sql": _1_create_records_down_sql,
	"1_create_records.up.sql":   _1_create_records_up_sql,
}

// AssetDir returns the file names below a certain
// directory embedded in the file by go-bindata.
// For example if you run go-bindata on data/... and data contains the
// following hierarchy:
//     data/
//       foo.txt
//       img/
//         a.png
//         b.png
// then AssetDir("data") would return []string{"foo.txt", "img"}
// AssetDir("data/img") would return []string{"a.png", "b.png"}
// AssetDir("foo.txt") and AssetDir("notexist") would return an error
// AssetDir("") will return []string{"data"}.
func AssetDir(name string) ([]string, error) {
	node := _bintree
	if len(name) != 0 {
		cannonicalName := strings.Replace(name, "\\", "/", -1)
		pathList := strings.Split(cannonicalName, "/")
		for _, p := range pathList {
			node = node.Children[p]
			if node == nil {
				return nil, fmt.Errorf("Asset %s not found", name)
			}
		}
	}
	if node.Func != nil {
		return nil, fmt.Errorf("Asset %s not found", name)
	}
	rv := make([]string, 0, len(node.Children))
	for name := range node.Children {
		rv = append(rv, name)
	}
	return rv, nil
}

type _bintree_t struct {
	Func     func() ([]byte, error)
	Children map[string]*_bintree_t
}

var _bintree = &_bintree_t{nil, map[string]*_bintree_t{
	"1_create_records.down.sql": &_bintree_t{_1_create_records_down_sql, map[string]*_bintree_t{}},
	"1_create_records.up.sql":   &_bintree_t{_1_create_records_up_sql, map[string]*_bintree_t{}},
}}

// Code generated by sqlc. DO NOT EDIT.
// source: position.sql

package db

import (
	"context"
)

const getPosition = `-- name: GetPosition :one
SELECT updated, created, stream, listener, no, data, content_type
FROM po_pos
WHERE stream = $1
  AND listener = $2
    FOR UPDATE
`

type GetPositionParams struct {
	Stream   string `json:"stream"`
	Listener string `json:"listener"`
}

func (q *Queries) GetPosition(ctx context.Context, arg GetPositionParams) (PoPo, error) {
	row := q.db.QueryRowContext(ctx, getPosition, arg.Stream, arg.Listener)
	var i PoPo
	err := row.Scan(
		&i.Updated,
		&i.Created,
		&i.Stream,
		&i.Listener,
		&i.No,
		&i.Data,
		&i.ContentType,
	)
	return i, err
}

const setPosition = `-- name: SetSubscriberPosition :exec
INSERT INTO po_pos (stream, listener, no, content_type, data)
VALUES ($1, $2, $3, 'application/json', '{}'::bytea)
ON CONFLICT (stream, listener) DO UPDATE
    SET no      = $3,
        updated = NOW()
WHERE po_pos.stream = $1
  AND po_pos.listener = $2
`

type SetPositionParams struct {
	Stream   string `json:"stream"`
	Listener string `json:"listener"`
	No       int64  `json:"no"`
}

func (q *Queries) SetPosition(ctx context.Context, arg SetPositionParams) error {
	_, err := q.db.ExecContext(ctx, setPosition, arg.Stream, arg.Listener, arg.No)
	return err
}
